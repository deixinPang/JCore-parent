##  一、Simple-简单模型(Queue)

生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。



##  二、Work-工作模型(Queue)

叫工作队列或竞争消费者模式。

 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。

        这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。
#### 模拟流程：

1、生产者与案例1中的几乎一样：不过这里我们是循环发送50条消息。

2、消费者1 设置Thread.sleep(2000)； 消费者2什么也不用设置

接下来，两个消费者一同启动，然后发送50条消息： 可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。

能者多劳-->把任务平均分配，正确的做法应该是消费越快的人，消费的越多

可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。

### 三、Fanout-广播模型（Queue+Exchange）

1） 可以有多个消费者

2） 每个消费者有自己的queue（队列）

3） 每个队列都要绑定到Exchange（交换机）

4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。

5） 交换机把消息发送给绑定过的所有队列

6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费



### 四、Direct-定向模型（Queue+Exchange+routing key）

- 有选择性的接收消息
- 在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。
- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）
- 消息的发送方在向Exchange发送消息时，也必须指定消息的routing key

### 五、Topic-主题模型（在Direct基础上支持通配符）

Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！
Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert

通配符规则：

> `#`：匹配一个或多个词
>
> `*`：匹配不多不少恰好1个词

举例：

> ```
> audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs
> audit.*`：只能匹配`audit.irs
> ```